# -*- coding: utf-8 -*-
"""ДЗ_№3 «Библиотека pandas».ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FyHOAJsBO129eY7Afstv0Nrah9B4KSN3

**Задание 1**
Для датафрейма log из материалов занятия создайте столбец source_type по правилам:

*   если источник traffic_source равен Yandex или Google, то в source_type ставится organic;
*   для источников paid и email из России ставим ad

*   для источников paid и email не из России ставим other
*   все остальные варианты берём из traffic_source без изменений

**МЕТОД LOC**
"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# import pandas as pd
# 
# visit_log = pd.read_csv('visit_log.csv', sep=';', encoding='utf-8')
# 
# visit_log.loc[(visit_log['traffic_source'] == 'yandex') | (visit_log['traffic_source'] == 'google'), ['source_type']] = 'organic'
# visit_log.loc[((visit_log['traffic_source'] == 'paid') | (visit_log['traffic_source'] == 'email')) & ( visit_log['region'] != 'Russia'), ['source_type']] = 'other'
# visit_log.loc[((visit_log['traffic_source'] == 'paid') | (visit_log['traffic_source'] == 'email')) & (visit_log['region'] == 'Russia'), ['source_type']] = 'ad'
# 
# visit_log.head(10)
# # для проверки
# #visit_log.loc[(visit_log['region'] != 'Russia') & (visit_log['traffic_source'] == 'email'), ['region', 'traffic_source', 'source_type']]
#

visit_log_pivot = visit_log.pivot_table(index='region', columns='source_type', values='traffic_source', aggfunc='count')
visit_log_pivot.head(10)

"""**Через функцию**"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# import pandas as pd
# 
# visit_log = pd.read_csv('visit_log.csv', sep=';', encoding='utf-8')
# 
# def source_type(row):
#   if row['region'] == 'Russia' and  (row['traffic_source'] == 'paid' or row['traffic_source'] == 'email'):
#     return 'ad'
#   elif row['region'] != 'Russia' and (row['traffic_source'] == 'paid' or row['traffic_source'] == 'email'):
#     return 'other'
#   elif row['traffic_source'] == 'yandex' or  row['traffic_source'] == 'google':
#     return 'organic'
# 
# visit_log['source_type'] = visit_log.apply(source_type, axis=1)
# 
# visit_log.head(10)
# #visit_log_pivot = visit_log.pivot_table(index='region', columns='source_type', values='traffic_source', aggfunc='count')
# #visit_log_pivot.head(10)

"""**Задание 2**
В файле URLs.txt содержатся URL страниц новостного сайта. Вам нужно отфильтровать его по адресам страниц с текстами новостей. Известно, что шаблон страницы новостей имеет внутри URL конструкцию: /, затем 8 цифр, затем дефис. Выполните действия:


1.   Прочитайте содержимого файла с датафрейм.
2.   Отфильтруйте страницы с текстом новостей, используя метод str.contains и регулярное выражение в соответствие с заданным шаблоном.


"""

from operator import index
import pandas as pd
URLs = pd.read_csv('URLs.txt', sep=',')
URLs.head()


URLs[URLs['url'].str.contains('/[0-9]{8}-', case=False)].head()
#URLs[URLs['url'].str.contains('/[0-9]{8}-', regex=True)]  #  В чём принципиальная разница между case=False и regex=True

"""**Задание 3**
Используйте файл с оценками фильмов ml-latest-small/ratings.csv. Посчитайте среднее время жизни пользователей, которые выставили более 100 оценок. Под временем жизни понимается разница между максимальным и минимальным значениями столбца timestamp для данного значения userId.
"""

import pandas as pd
ratings = pd.read_csv('/content/ratings.csv', sep=',')
ratings.head(3)

#  1_Вариант создания СВОДНОЙ ТАБЛИЦЫ
ratings_pivot = ratings.groupby(['userId']).agg(MIN_TIME=('timestamp','min'), MAX_TIME=('timestamp','max'), COUNT=('rating', 'count'))
ratings_pivot.sort_values(by='COUNT', ascending=False).head()

#  2_Вариант создания СВОДНОЙ ТАБЛИЦЫ
ratings_pivot = ratings.groupby(['userId']).agg({'timestamp': ['min', 'max', 'count']})['timestamp'].sort_values(by='count', ascending=False)
ratings_pivot.head()

# Commented out IPython magic to ensure Python compatibility.
# %%time
# #  Вариант с функцией
# def T_Life (row_table):
#   T_ = row_table['max'] - row_table['min']
#   if row_table['count'] > 100:
#     return T_
# 
# ratings_pivot['T_Life'] = ratings_pivot.apply(T_Life, axis=1)
# ratings_pivot[ratings_pivot['count'] > 100]
# 
# ratings_pivot['T_Life'].mean()

# Commented out IPython magic to ensure Python compatibility.
# %%time
# #  Вариант с функцией loc
# ratings_pivot.loc[ratings_pivot['count'] > 100, ['T_Life']] = (ratings_pivot['max'] - ratings_pivot['min'])
# 
# mean_ = ratings_pivot['T_Life'].mean()
# print(f'Cреднее время жизни пользователей, которые выставили более 100 оценок - {mean_}')

"""**Задание 4.** Дана статистика услуг перевозок клиентов компании по типам (см. файл “Python_13_join.ipynb” в разделе «Материалы для лекции “Продвинутый pandas”» ---- Ноутбуки к лекции «Продвинутый pandas»).
Нужно сформировать две таблицы:


1.   таблицу с тремя типами выручки для каждого client_id без указания адреса клиента;
2.   аналогичную таблицу по типам выручки с указанием адреса клиента.

**К домашнему заданию №4**
Дана статистика услуг перевозок клиентов компании по типам:

*   rzd - железнодорожные перевозки
*   auto - автомобильные перевозки
*   air - воздушные перевозки
*   client_base - адреса клиентов
"""

import pandas as pd

rzd = pd.DataFrame(
    {
        'client_id': [111, 112, 113, 114, 115],
        'rzd_revenue': [1093, 2810, 10283, 5774, 981]
    }
)
rzd

auto = pd.DataFrame(
    {
        'client_id': [113, 114, 115, 116, 117],
        'auto_revenue': [57483, 83, 912, 4834, 98]
    }
)
auto

air = pd.DataFrame(
    {
        'client_id': [115, 116, 117, 118],
        'air_revenue': [81, 4, 13, 173]
    }
)
air

client_base = pd.DataFrame(
    {
        'client_id': [111, 112, 113, 114, 115, 116, 117, 118],
        'address': ['Комсомольская 4', 'Энтузиастов 8а', 'Левобережная 1а', 'Мира 14', 'ЗЖБИиДК 1',
                    'Строителей 18', 'Панфиловская 33', 'Мастеркова 4']
    }
)
client_base

# РЕШЕНИЕ
concat_tabl_revenue = pd.concat([rzd, auto, air])
concat_tabl_revenue

#таблица с тремя типами выручки для каждого client_id без указания адреса клиента

pivot_tabl_revenue = concat_tabl_revenue.groupby('client_id').sum()
#pivot_tabl_revenue['SUMMA'] = pivot_tabl_revenue.loc[:,['rzd_revenue', 'auto_revenue', 'air_revenue']].sum(axis=1)
pivot_tabl_revenue.eval('SUMMA = rzd_revenue + auto_revenue + air_revenue', inplace=True)
pivot_tabl_revenue.sort_values(by='SUMMA', ascending=False, inplace=True)
pivot_tabl_revenue

#Для проверки суммы и потери данных (84622.0)
#pivot_tabl_revenue['SUMMA'].sum()

# Аналогичная таблица по типам выручки с указанием адреса клиента
pivot_tabl_revenue.merge(client_base, how='left', on='client_id')

#Для проверки суммы и потери данных (84622.0)
#pivot_tabl_revenue['SUMMA'].sum()